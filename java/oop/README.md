## OOP(Object Oriented Programming)

##### 객체 지향 프로그래밍에서는 객체가 속한 클래스에 객체의 동작을 정의하고, 객체를 사용해 작업을 수행한다. 자바는 객체 지향 프로그래밍을 완전히 수용한 첫 번째 주류 프로그래밍 언어다.  

[뒤로가기](/java/README.md)

시간을 거슬러 객체를 발명하기 전으로 돌아가보면, 당시에는 함수를 호출하는 방식으로 프로그램을 작성했다.  

이미 알고있는 것처럼 이러한 함수는 호출되면 body의 작업을 수행하고, 결과를 반환한다. 이 결과를 어떻게 계산했는지 신경 쓸 필요 없이 그냥 사용하면 된다.  

그래서 함수를 사용하면 작업을 공유할 수 있게 된다. 작업 방법을 몰라도 다른 누군가가 작성한 함수를 호출할 수 있다.  

### 객체를 사용해보자.

앞으로 설명할 '객체'는 여기에 한 차원을 더했다. 객체마다 자신만의 상태(state)가 있다. 이 상태는 메서드를 호출해서 얻는 결과에 영향을 준다. 예를 들어 in이 Scanner의 객체일 때 in.next()를 호출하면 in 객체는 이전에 무엇을 읽었는지 기억하고 다음 입력 토큰을 준다. 현재 in은 자세히 알 수는 없지만 어떠한 상태라는 갖는다는 점을 기억하자.  

다른 사람이 구현한 객체의 메서드를 호출할 때는 내부에서 무슨 일이 일어나는지 몰라도 괜찮다고 했다. 이것은 객체 지향 프로그램의 핵심이며  캡슐화(encapsulation)라고 한다.  

달력의 날짜를 조작하는 작업을 생각해보자. 달력은 월마다 길이가 다르고, 윤년과 윤초까지 있어서 다루기가 좀 까다롭다. 이런 까다로운 세부 사항을 이해하고, 다른 프로그래머가 사용할 수 있는 구현체를 만들어 제공하는 전문가가 있다면 얼마나 좋겠는가!  

이 상황에서 자연스럽게 객체가 등장한다. 예를 들어 날짜 객체의 메서드는 오늘의 요일이나 내일의 날짜 같은 정보를 제공한다.  

자바에서는 날짜를 이해하는 전문가가 날짜와 다른 날짜 관련 개념을 표현하는 클래스를 만들어 제공한다. 날짜를 계산하고 싶다면 이 클래스 중 하나를 사용해 날짜 객체를 생성하고, 요일이나 다음 날짜를 돌려주는 메서드 등을 호출하면 된다.  

이처럼 날짜에 대한 전문가가 그 틀을 클래스로 만들어 제공하고, 우리는 그 클래스를 이용해 날짜 객체를 생성해 사용하자는 이론이 객체 지향 프로그래밍의 밑바탕이 된다. 이제 본격적으로 객체 지향 프로그래밍을 살펴보자.  

#### 달력 만들기  

[예제](/java/acting/ch02/sec01/Cal.java)  

위 예제를 참고하여 객체를 만들어 달력을 구현하는 과정을 살펴보자.  

```
// 만약 acting directory에서 진행한다면 다음을 따라하자.  
javac ch02/sec01/Cal.java

// 현재 날짜의 달력이 나온다.
java ch02.sec01.Cal

// 2018년 06월의 달력이 나온다.
java ch02.sec01.Cal 6 2018
```
  
이제 위의 코드를 살펴보며 'date.plusDays(1)' 메서드 호출을 생각해보자. LocalDate 클래스의 설계자들은 plusDays라는 메서드를 생성할 때 두 가지 방법으로 구현할 수 있었다. 첫 번째 방법은 date 객체의 상태를 변경하고 아무 것도 반환하지 않는다. 두 번째 방법은 date를 변경하지 않고 새로 생성된 LocalDate 객체를 반환하여 다시 date에 넣는다. 예제를 보면 알겠지만 설계자들은 두 번째 방법을 선택했다.  

호출되는 객체를 변경하는 메서드를 'mutator'라고 부른다. 객체를 변경하지 않는 메서드를 'accessor'이라고 부른다. 예를 들어 앞선 LocalDate 클래스의 plusDays는 accessor이다.  

대부분의 메서드가 accessor의 형태를 띄는데, 이는 객체 변경은 위험할 수 있기 때문(특히 두 연산이 객체 하나를 동시에 변경할 때)이다. 이러한 메커니즘의 가장 큰 이유는 CPU의 동시 접근성이 발달함에 따라 이에 대한 안전성이 중요한 문제가 되었기 때문이다. 이 문제를 해결하는 방법 중 하나로 accessor 메서드만 제공해 객체를 'immutable'한 상태로 유지하는 것이다.  

그래도 여전히 변경이 필요할 때가 많다. ArrayList 클래스의 add 메서드가 대표적인 예이다. add를 호출하면 배열 리스트 객체가 변경된다.  

```
ArrayList<String> friends = new ArrayList<>();
	// friends가 비어있다.  
friends.add("Peter");
	// friends의 크기가 1이다.  
```
  
#### 자바에서의 객체 지향

C++ 같은 일부 프로그래밍 언어에서는 변수에 실제 객체(즉, 객체의 상태를 구성하는 비트들)를 담을 수 있다. 그러나 자바에서는 그렇지 않다.  

변수에는 오직 객체 reference만 담을 수 있다. 실제 객체는 다른 곳에 있고, reference는 실제 객체를 찾아내는 구현체 고유의 방법이다.  

> reference는 아주 안전하다는 점을 제외하면 C/C++의 포인터 혹은 참조자와 유사하게 작동한다. C/C++에서는 포인터를 수정하고 포인터로 임의의 메모리 위치를 덮어쓸 수 있다. 하지만 자바의 reference는 특정 객체에만 접근이 가능하다.  

객체 reference(이하 참조)를 담은 변수를 다른 변수에 할당하면 같은 객체 참조를 두 개 갖는다.  

```
ArrayList<String> people = friends;
	// 이제 people과 friends는 같은 객체를 참조한다.  
```
  
공유된 객체를 변경하면 두 참조로 해당 변경 사실을 알 수 있다. 즉, 이 둘은 같은 곳을 가리키고 있다. 여기서 알 수 있는 건 people이나 friends는 객체가 아니고, 같은 배열 리스트 객체의 참조일 뿐이라는 것이다.  

대부분은 이렇게 객체를 공유하면 효율적이고 편리한데, 둘 중 어던 참조로도 공유 객체를 변경할 수 있다는 점에 유의하자.  

하지만, 앞서 봤던 LocalDate나 String과 같은 클래스에 mutator 메서드가 없다면 걱정하지 않아도 된다. 어떤 메서드도 객체를 변경할 수 없으므로 해당 객체에 대한 참조를 얼마든지 공유할 수 있다. 즉, 상태에 대한 고려를 하지 않아도 괜찮다는 말이다.  

마지막으로 다음 할당을 살펴보자.  

```
date = LocalDate.of(year, month, 1);
date = date.plusDays(1);
```
  
첫 번째 할당 후에 date는 지정한 연, 월의 1일을 가리킨다. plusDays 호출은 새 LocalDate 객체를 돌려주며, 두 번째 할당 후 date 변수는 새 객체를 참조한다. 그렇다면 첫 번째 객체는 사라지는 것일까?  

첫 번째 객체는 그것과 관련된 참조가 사라지므로(date의 초기화) 더는 필요 없다. 결국에는 가비지 컬렉터가 메모리를 정리해서 재사용할 수 있게 한다. 자바에서는 이 과정이 자동으로 일어나므로 프로그래머는 메모리 할당 해제를 전혀 걱정하지 않아도 된다.  

### 클래스를 구현해보자.  

본격적으로 클래스를 만들어보자. C++과 같은 다른 객체 지향 프로그래밍 언어에서 다뤄봤었을 수 있지만, 다시 한 번 익히고 넘어가도록 하자.  

우선 Employee 클래스를 만들어 가며 다양한 언어 규칙을 살펴보도록 하자. 직원에게는 이름과 금여가 있다. 직원의 이름은 바꿀 수 없지만 그가 받는 급여는 알맞게 수시로 조절할 수 있다.  

```
public class Employee {
	private String name;
	private double salary;
}
```
  
앞선 설명과 같이 이름과 급여를 넣을 변수를 생성했다. 자바에서는 '인수턴스 변수'라고 부르며 객체의 상태를 나타낸다.  

자바에서는 보통 인스턴스 변수를 private으로 선언한다. private으로 선언하면 같은 클래스에 속한 메서드만 변수에 접근할 수 있다. 이런 보호가 바람직한 이유는 아래의 2가지이다.  

1. 프로그램의 어느 부분이 변수를 변경할 수 있는지 제어할 수 있다.  
2. 언제든지 내부 표현을 변경할 수 있다.  

예를 들어 직원들을 데이터베이스에 저장하고 객체에는 오직 기본키만 남겨 둘 수도 있다. 이 경우 메서드를 이전과 똑같이 작동하도록 재구현한다면 클래스의 사용자는 이런 변경에 개의치 않을 것이다.  

#### Method Header  

이제 Employee class의 메서드를 구현해 보자. 메서드를 선언할 때는 메서드 이름, 매개변수의 타입과 이름, 반환 타입을 지정해야 한다.  

```
public void raiseSalary(double byPercent)
publice String getName()
```
  
이 메서드는 double 타입 매개변수를 한 개 받고, 어떤 값도 반환하지 않는다.  

반면, getName은 형태가 다르다. 이러한 형태를 두고 '시그니처(signature)(서명)'이라고 부른다. 이 메서드는 매개변수가 없고 String을 반환한다.  

#### Method body  

앞서 메서드 헤더를 만들었다. 그렇다면 이제는 그에 맞는 몸통을 만들 차례다.  

```
public void raise(double byPercent) { // Method Header
	double raise = salary * byPercent / 100;
	salary += raise;
}
```
  
메서드에서 값을 돌려줄 때는 return 키워드를 사용해야 한다는 것쯤은 알고 있을 것이다.  

```
public String getName() {
	return name;
}
```
  
메서드 선언은 클래스 선언 안에 넣어야 하는데, 다음과 같이 하나의 Employee Class를 만들 수 있다.  

```
public class Employee {
	private name;
	private salary;

	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}

	public String getName() {
		return name;
	}
	...
```
  
#### Instance Method  

메서드를 호출하는 상황을 살펴보자.  

```
fred.raiseSalary(5);
```
  
프레드라는 직원이 5퍼센트의 연봉인상을 요구해왔다. 이 호출에서 인수 5는 raiseSalary의 byPercent를 초기화하는 데 사용한다.  

```
double byPercent = 5;
```
  
이후 다음의 동작이 일어난다.  

```
double raise = fred.salary * byPercent / 100;
fred.salary += raise;
```
  
인스턴스 변수 salary는 메서드 호출에 사용한 인스턴스에 적용된다는 점을 명심하자. 클래스 자체가 아닌 인스턴스에 작동하는 이러한 메서드를 '인스턴스 메서드'라고 부른다.  

> 자바에서 static으로 선언하지 않은 메서드는 모두 인스턴스 메서드이다.  

코드를 보며 한 가지 이상한 점을 발견하지 못했는가? 그것은 바로 fred의 존재이다. 일반적으로 함수에서 인수를 전달하면, 그 인수만 함수 내에서 어떠한 작업을 진행하는 것이 객체 지향 프로그래밍 이전의 개발이었다.  

하지만, 여기서는 fred의 존재로 인해 위의 메서드에 2개의 값이 전달되는 기적같은 일이 일어난다. 이러한 존재를 '객체에 대한 참조'라고 일컬을 수 있고, 메서드 내에서 사용할 수 있다.  

기술적으로는 객체에 대한 참조나 byPercent 둘 다 메서드의 매개변수이지만, 자바에서는 다른 객체 지향 언어처럼 첫 번째 값(객체에 대한 참조)이 특별한 역할을 한다.  

이러한 값을 메서드 호출의 receiver(수신자)라고 부르기도 한다.  

#### this 참조  

하나의 객체의 메서드를 호출할 때 해당 객체를 참조할 수 있다. 이를 'this'로 설정하여 다루면 되는데, 다음을 참고하자.  

```
public void raiseSalary(double byPercent) {
	double raise = this.salary * byPercent / 100;
	this.salary += raise;
}
```
  
일부 개발자는 지역 변수와 인스턴스 변수를 명확히 구별하려고 이러한 스타일(this 방식)을 선호한다. 이러한 스타일에 익숙해지면 위 코드를 보고 한 번에 raise 는 local 변수, salary는 인스턴스 변수라는 사실을 금새 알 수 있기 때문이다.  

또한, local과 instance를 구분하여 같은 이름의 변수를 만들 수 있다.  

```
public void setSalary(double salary) {
	this.salary = salary;
}
```
  
이렇게 instance와 local의 이름이 같을 때 salary처럼 한정하지 않은 이름은 local을, this.salary는 instance를 나타낸다.  

> 일부 언어에서는 인스턴스 변수를 _name이나 _salary 식으로도 쓴다. 이는 자바에서도 가능하지만, 선호하지 않는다.  
>
> 원한다면 this를 메서드의 매개변수로도 선언할 수 있다(생성자의 매개변수에서는 불가능하다). 이는 보통 reciver에 애너테이션을 붙이는 용도로만 사용하니 참고하도록 하자.  

#### 값을 사용한 호출  

매서드에 객체를 전달하면 해당 메서드는 객체 참조의 사본을 얻는다. 메서드는 이 참조로 매개변수 객체에 접근하거나 매개변수 객체를 변경할 수 있다.  

```
private class EvilManager {
	private Random generator;
	...
	public void giveRandomRaise(Employee e) {
		double percentage = 10 * generator.nextGaussian();
		e.raiseSalary(percentage);
```
  
다음과 같이 호출한다고 하자.  

```
boss.giveRandomRaise(fred);
```
  
그러면 fred를 e 매개변수에 복사하고, giveRandomRaise 메서드는 두 참조가 공유하는 객체를 변경한다(e와 fred가 공유하는 객체를 말이다).  

자바에서는 기본 타입 매개변수를 업데이트하는 메서드를 작성할 수 없다. 예를들어 double의 값을 증가시키는 아래의 메서드는 의도한 대로 작동하지 않는다.  

```
public void increaseRandomly(double x) {
	double amount = x * getnerator.nextDouble();
	x += amount;
}
```
  
이를 다음과 같이 호출한다고 해보자.  

```
boss.increaseRandomly(sales);
```
  
그러면 sales가 x로 복사된다. 다음으로 x를 증가시키지만 sales는 변하지 않는다. 이후 매개변수는 유효 범위를 벗어나고 증가 연산은 효력을 잃는다.  

같은 이유로 객체 차모를 다른 것으로 바꾸는 메서드도 작성할 수 없다. 예를 들어 다음 메서드는 의도한 대로 작동하지 않는다.  

```
public class EvilManager {
	...
	public void replaceWithZombie(Employee e) {
		e = new Employee("", 0);
	}
}
```
  
다음과 같이 호출하면 참조 fred가 e변수로 복사될 것이다.  

```
boss.replaceWithZombie(fred);
```
  
그런 다음 e는 다른 참조로 설정된다. 메서드가 끝날 때 e는 유효 범위를 벗어난다. 결국 fred는 어디서도 변경되지 않았다. 이는 local이기 때문이라고 이해하면 쉽게 넘어갈 수 있을 것이다.  

> 자바는 객체에 '참조를 이용한 호출'을 사용한다고 말하는 사람도 더러 있다. 두 번째 예제에서 보았듯이 이 말은 사실이 아니다. 참조를 이용한 호출을 지원하는 언어에서는 메서드가 전달받은 변수의 내용을 다른 것으로 교체할 수 있다. 자바에서는 기본 타입 값은 물론 객체 차조까지 모든 매개변수가 값으로 전달된다.  


