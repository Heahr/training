## Database terms1  

##### 

[뒤로가기](/database/README.md)

이번 장에서는 데이터베이스 프로그래밍을 위해 필요한 데이터베이스의 기본 개념들에 대해 간략하게 설명할 것이다. 자세한 내용은 포털의 검색을 통해 진행하면 된다.  

---

**데이터베이스**: 일반적으로 '데이터가 들어가 있는 테이블의 집합'이라고 할 수 있다. 이러한 테이블은 2차원 배열로 구성되어 있다.  


**DBMS**: DataBase Management System의 약자로, 데이터베이스라는 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용프로그램이다. 즉, 아래와 같다.  

> **DBMS**  : 데이터의 관리에 특화된 프로그램
  
대표적인 기능으로는 동일한 데이터가 여러 위치에 **'중복 저장되는 것을 방지/제어'**하고, 사용자마다 다양한 권한을 부여하고, 권한에 따라 데이터에 **'접근을 제어/통제'**하고, 사용자에게 SQL, CLI, GUI 등 다양한 **'인터페이스를 제공'**하고, 서로 다른 데이터간의 다양한 관계를 표현할 수 있는 기능인 **'관게 표현'**, 구조 최적화를 위해 작은 단위로 구조를 쪼개는 **'샤딩/파티셔닝'**, **'무결성에 관한 제약 조건'**을 정의/검사하는 기능과 **백업/회복(Recovery)**을 제공한다.  

> **중복 제어**
> **접근 제어**
> **다양한 인터페이스 제공**
> **데이터간의 다양한 관계를 표현**
> **샤딩/파티셔닝**
> **무결성 제약 조건**
> **백업/회복**  

이러한 DBMS는 모든 종류의 데이터를 관리하는 최선의 방법이 아니다. 최소한 DBMS를 다시 만들거나, 다른 DBMS와 결합하여 사용하는 것이 일반적이다. 아래가 그 일반적인 경우이다.

> 복잡한 DBMS일수록 트랜잭션, ACID 등의 많은 컨셉을 지원하기 위한 오버헤드가 발생한다.  
>
> 때문에 휴대전화, 임베디드 기기같은 단순한 데이터베이스의 경우에는 다중사용자나 회복 기능등을 뺀 단순한 DBMS를 만들어 사용하기도 한다. 
>
> 많은 DBMS는 비교적 크기가 작은 레코드를 수백만개씩 저장하는 것에 특화되어있다. 반대로 하나의 레코드가 몇십MB에서 GB급인 경우 데이터를 DB에 저장하면 쿼리 시 오버헤드가 클 수 있다.  
> 
> 이 경우 원래 파일은 파일 시스템에 직접 저장하거나 파일 시스템 스타일의 클라우드(Amazon S3 등)를 이용하고 그 경로만 DB에 저장하는게 바람직하다.
>
> 더불어 실시간 데이터 처리가 필요한 경우(예를 들어 군용, 항공/우주용 등)에도 일반적으로 복잡한 기능을 제공하는 DBMS가 적합하지 않다.  
>
> 다만, 통신망, 금융권등에서의 실시간 데이터 처리 개념에서는 오라클의 '타임스텐'이나 알티베이스의 '알티베이스 HDB'와 같은 MM DBMS(Main Memory DBMS) 또는 인 메모리 데이터베이스 제품을 실시간 데이터 처리가 요구되는 구간에 사용하고 이력 데이터와 같은 저장성이 중요시 되는 데이터는 back-end 구간에 전통적인 디스크 기반 DBMS를 사용하는 방식으로 시스템을 구성하기도 한다.
>
> 검색엔진등 극단적으로 데이터가 크며, READ/WRITE간의 격차가 큰 경우에도 일반적인 DBMS를 사용하지 않는다. 이러한 경우는 MM DBMS와 No SQL 기술을 혼용하여 서비스를 구축한다. No SQL 기술이 응용된 사례가 페이스북의 쪽지 기능이다.  

---

**데이터 모델링(Data Modeling**: 데이터 모델링이란 주어진 개념으로부터 논리적인 데이터 모델을 구성하는 작업을 말한다.  

일반적으로 이를 물리적인 데이터베이스 모델로 환원하여 고객의 요구에 따라 특정 정보 시스템의 데이터베이스에 반영하는 작업을 포함한다(흔히 후자의 의미로 데이터베이스 모델링이라고 불린다).  

> 데이터 모델링을 해 나갈 때는, 사람들은 데이터를 구조화하고 조직화한다. 뒤이어 이러한 데이터 구조는 데이터베이스 관리 시스템(DBMS) 상에서 구현된다.  
>
> 데이터를 정의하고 조직화하는 것 외에도, 데이터 모델링은 (명시적으로나 비명시적으로) 구조 안에 들어갈 데이터의 제약 조건이나 범위를 규정해 나가게 된다.  
>
> 구조화되었거나 구조화 안 되었거나 거대한 양의 데이터를 관리하는 것이 정보 시스템의 주요 기능이다.  
>
> 하지만 관계형 데이터베이스와 같은 데이터 관리 시스템 상의 저장소에 담을 구조적인 데이터를 기술하는 것이 데이터 모델이다.  
>
> 데이터 모델은 구조화되지 않은 것들, 예를 들어 문서 편집기로 작성한 문서, 이메일 메시지 등은 보통 기술하지 않는다.  

---

**엔터티(Entity)**: 한국 데이터베이스 진흥원에서의 정의는 **"업무 활동상 지속적인 관심을 가지고 있어야 하는 대상으로서, 그 대상들 간에 동질성을 지닌 것으로 볼 수 있는 개체 집합이나 그들이 행하는 행위의 집합으로 정의할 수 있다."**이고, 우리가 이해하기 쉬운 일반적인 정의는 아래와 같다.  

> 현실 세계에서 다른 모든 것들과 구분되는 유형, 무형의 것을 엔터티라고 정의하며 업무 수행을 위해서 알아야 될 대상이 되는 유형, 무형의 것을 엔터티로 정의한다. 즉, 데이터로 관리되어야 하는 항목을 엔터티로 정의한다.
>
> 추가적으로 동질성이란 집합을 어떻게 정의하느냐에 따라 달라질 수 있는데, 집합에 들어갈 개체들의 동일한 성질을 어디까지로 한정할 것인지를 결정하는 것으로 동질성 유무를 판단할 수 있다.  

---

**엔터티(Entity) 도출/파악**: 엔터티를 도출하는 방법은 아래와 같이 3가지이다.  

1. 명사형 도출  
2. 정규화 이용  
3. 엔터티타입 구분에 의한 4-STEP 데이터 모델링  
  

우선 **'명사형 도출'**은 장표나 업무기술서 등에서 명사를 구분하여 이것을 엔터티타입의 후보로 삼은 다음 일정한 기준에 의해 판단하는 방법이다.  

초기에 가장 많이 사용하는 방법 중 하나이다. 과정은 다음과 같다.   

1. 문서에서 명사를 구분  
2. 개념이 불분명한 것, 광범위한 것 제거  
3. 앤티티타입의 특성이거나 속성의 값을 제거  
4. 포괄적인 업무 프로세스에 해당하는 명사 제거  
5. 중복되는 명사 제거  

다음에는 **'정규화 이용'**에 대해 알아보도록 하자.  

1. 해당 업무에서 발생하는 데이터를 장표의 표현 방법에 의해 나열  
2. 나열된 데이터에서 1 ~ 5차 정규화와 BCNF를 적용  

다소 간단하지만, 이렇게 하면 업무적으로 발생하는 모든 데이터에 대해 합리적으로 엔터티타입을 도출할 수 있다.  

마지막으로 **'엔터티타입 구분에 의한 4-STEP 데이터 모델링'**에 대한 설명을 하지면, 말 그대로 4-STEP을 거쳐 데이터 모델링을 전개한다. 아래와 같이 말이다.  

1. 업무 구조 모델링  
2. 업무 흐름 모델링  
3. 모델의 기술적 접근에 의한 모델링  
4. 모델의 검토 및 정제를 통한 모델링  

이 방법은 업무를 잘 이해한 상태에서 기본 엔터티타입을 먼저 도출하여 모델링 툴에 나열하고, 그 다음 중심 엔터티타입을 도출하여 모델링 툴에 나열한 다음 여기에 업무를 흘려보내 관계를 연결하며 행위 엔터티타입을 도출하는 식으로 도출된다.  

엔터티타입의 구분에 따라 기본->중심->행위로 엔터티타입을 구분해야 빠르고도 정확하게 엔터티타입을 도출할 수 있다.  

---

**서브타입 엔터티(Subtype Entity)**: 정의 자체는 엔터티와 동일하다. 슈퍼타입과 한쌍을 이룬다는 것이 다른 점이다.  

설명에 앞서 서브타입이란 서브타입 엔터티를 말한다는 것과 슈퍼타입도 마찬가지로 슈퍼타입 엔터티를 의미한다는 것을 알아두도록 하자.  

이러한 서브타입과 슈퍼타입은 엔터티를 '일반화'하거나, '상세화'할 때 발생한다.  

즉, 엔터티를 분리하거나 통합하는 경우에 발생하는 것이 서브타입이다. 결과적으로 유사한 엔터티의 공통 속성은 슈퍼타입으로, 고유 속성은 서브타입 엔터티로 간다. 정리하면 아래와 같다.  

> 유사한 엔터티를 하나로 묶거나 분리할 때 슈퍼타입과 서브타입이 나뉜다.  
>
> 슈퍼타입은 유사한 엔터티의 공통 속성이고, 서브타입은 각 엔터티의 고유 속성이라고 할 수 있다.  

---

**속성(Attribute)**: 이는 엔터티에 저장되는 개체 집합의 특성을 설명하는 항목이라고 할 수 있다.  

아무리 엔터티를 명확하고 구체적으로 정의했다 하더라도 이것만으로는 개체 집합의 특성을 설명하기에는 부족함이 있다.  

그렇기에 따로 엔터티의 '속성'을 부여할 필요가 있다. 예를 들면 아래와 같다.

##### '학생'의 속성  

1. 학번   
2. 이름  
3. 평점  
4. 등록일자  
5. 생일  

---

**데이터베이스 설계의 3단계**: 데이터베이스는 아래와 같은 설계 단계를 거친다.  

1. 개념적 설계  
2. 논리적 설계  
3. 물리적 설계    

개념적 설계에서는 ER-D라고 부르는 '개체-관계 다이어그램'이 사용된다. 이에 대해서는 다음 설명에서 이야기하겠다.  

개념적 설계는 말 그대로 현실세계에 있는 Factor들을 데이터의 형태로 설계하는 단계이다. 정리하면 아래와 같다.  

> 개념적 설계 : 정보의 구조를 얻기 위해 현실 세계의 무한성과 계속성을 이해하고 다른 사람과 통신하기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정  

논리적 설계는 관계 스키마(Relation Schema) 개념적 설계에서 표현된 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한 것이다. 정리하면 아래와 같다.  

> 논리적 설계 :  현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정   

물리적 설계는 설명없이 정리만 봐도 좋다. 말 그대로 논리적인 데이터를 물리적 저장장치에 저장할 수 있도록 물리적 구조의 데이터로 변환하는 과정이기 때문이다.  

> 물리적 설계 : 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정  

---

**ER-D**: 위에서도 잠깐 언급했지만, Entity-Relationship Diagram의 약자로 '개체-관계 다이어그램'이라고 부른다.  

데이터베이스에 저장된 데이터의 구조 및 그에 수반한 제약 조건들은 다양한 기법에 의해 설계될 수 있는데 그 중 하나가 이 개체-관계 다이어그램이다. 

> 데이터 모델링 시 데이터 모델을 표현하기 위한 방법이라고 생각하면 된다.   

---

**식별자(Identifier)**: 엔터티의 각 개체들은 인스턴스라고 하는데, 인스턴스는 그들을 지칭하거나 식별해주는 속성인 '식별자'를 가지고 있다. 예를 들면, 직원 인스턴스는 직원번호, 주민번호, 직원 명으로 식별될 수 있다.  

또한, 식별자는 하나 도는 그 이상의 속성(Attribute)으로 구성된다. 특히 두 개나 그 이상의 속성으로 이루어진 식별자를 '복합 식별자'라 부른다.  

---

**관계(Relationship)**: 엔터티와 엔터티 간 연관성을 표현하는 것으로, 엔터티의 정의에 따라 영향을 받기도 하고, 속성 정의 및 관계 정의에 따라서도 다양하게 변할 수 있다.  

엔터티 간의 논리적으로 존재할 수 있는 수많은 관계 중에서 정말로 의미가 있고 관리할 가치가 있는 관계를 식별해 낸다는 것이 쉬운 일은 아니라는 것을 참고하길 바 란다.  

---

**카디널리티(Cardiality)**: 카디널리티란 관계에 참여하는 하나의 개체에 대해 다른 엔터티에서 몇 개의 개체가 참여하는지를 나타낸 것이다.  

> 예를 들어, 한 명의 학생이 1개 이상 6개 이하의 과목에 등록할 수 있다면 카디널리티는(1, 6)이다.  
>
> 한 명의 교수가 최대 3개의 과목을 가르칠 수 있다면 카디널리티는 (0,3)이다. 보통 카디널리티는 (Min, Max)의 값 한 쌍으로 표현하는데, 여기서 Min은 관계에 참여하는 개체의 최소 개수, Max는 최대 개수를 의미한다.
>
> 이러한 카디널리티는 1:1, 1:M, N:M의 3가지 형태로 나타낼 수 있다.
> 1:1의 경우에는 예를 들어 10,000명의 사원이 있는 회사가 있다. 이 중에는 계약직도 존재하고, 계약직은 계약 정보에 따라 임금이 달라지게 된다.  
>
> 따라서 일반 정직원이 아닌 계약직만을 위한 계약 정보를 속성으로 추가시켜야 한다. 그런데 계약직 200명을 위해 정규직 9800명이 계약 정보를 가지게 된다면, 필요없는 정보를 가지고 있는 것이다.  
>
> 이건 null값을 허용해, 빈 데이터를 많이 가지고 있어야 하므로, 데이터의 정확성이 떨어질 수 있다. 이럴 경우에 1:1관계로 정규 사원과 계약 사원을 묶어, 두 집단을 따로 관리할 수 있다.  
> 이러한 1:1 관계는 잘 일어나지 않는다. 왜냐하면 1:1관계의 두 집단을 하나로 묶을 수 있는 개념이기 때문이다.
>
> 다음은 1:M 관계를 이야기하자면, 한 부서와 직원들 사이의 관계이다. 가장 흔한 관계이고, 대부분 1:M 관계를 지닌다.  
>
> 예를 들어 "한 명의 사원은 하나의 부서에만 소속된다."라고 이해하면 된다. 이때 관계 정의서는 주는 쪽과 받는 쪽, 두 줄이 필요하다.
>
> 참여 방법은 필수와 선택으로 나뉜다. 예를 들어 '각각의 사원은 한 부서에 속한다.'는 필수 참여 방법이고, '각 부서에는 여러 명의 사원이 존재할 수 있다.'는 선택 참여 방법이다.

---

**바커 표기법**: 바커 표기법은 영국 컨설팅 회사 CACI에 의해 처음 개발되었고 리차드 바커(Richard Barker)에 의해 지속으로 업그레이드 되었다. 오라클에서 Case Method(Custom Development Method)로 채택하여 사용하고 있다.   

---

**정보공학(IE) 표기법**: Information Engineering(I/E)은 1981년에 Clive Finkelstein과 James Martin이 공동 저술로 발표하였으며, 80년대 중반에 James Martin에 의해 그 체계가 정리되면서 본격적으로 활용이 되었다.  

> 정보공학 표기법은 정보시스템을 구축하는데 있어서 데이터 분석(Data Analysis)과 데이터베이스 설계(Database Design)를 위한 매우 유용한 기법으로 자리 잡게 되었다.  

이 모델은 관계의 다(Many) 쪽을 나타내기 위해 까마귀 발을 사용하기 때문에 때때로 까마귀 발모델(Crow’s Foot Model)이라 부른다.  

위 두 개념(바커, IE 표기법)에 대한 자세한 내용은 [compare][Baker 표기법과 IE 표기법의 차이]를 참고하도록 하자.  

[compare]: https://rjs1197.github.io/articles/2017-08/database-2  

바커 표기법의 경우 'DA#'에서 사용하고, I/E 표기법은 'ER-Win'에서 사용한다는 것을 알아두면 좋다.

---

**데이터 무결성**: 데이터 값이 정확한 상태를 의미한다.  

---

**데이터 정합성**: 어떤 데이터들이 값이 서로 일치하는 것을 의미한다.

중복 데이터를 많이 사용하면 데이터끼리 정합성을 맞추기 어렵다.

비정규형을 사용해 아노말리(Anomaly : 이상현상)가 발생하면 정합성이 깨진다.

정합성은 데이터가 서로 모순 없이 일관되게 일치해야 함(무결성 데이터가 정확하고 완전해야 함)을 의미한다.  

---

**참조 무결성**: 참조되는 엔터티의 주 식별자 값과 일치(=참조하는 기본키 값 중에 하나와 일치)하거나, 널(Null) 값이어야 함.
  

참조 무결성은 종종 기본 키 또는 키가 아닌 후보 키와 외래 키의 조합으로 강제 적용된다.  

참조 무결성이 강제 적용되면 외래 키가 선언된 관계 변수의 외래 키를 구성하는 속성(열)의 값은 그 관계 변수의 부모가 되는 관계 변수의 기본 키 값 또는 기본 키가 아닌 후보 키 값으로 존재해야 한다.  

예를 들어, 다른 관계 변수의 외래 키에 의해 참조되는 쌍(dupe 행)을 제거하는 것은 참조 무결성 을 파괴해 버리게 되기 때문에 관계 데이터베이스 관리 시스템(RDBMS) 참조 무결성을 유지하도록 일반적으로 삭제를 방지한다.  

예외적으로 참조하는 외래 키를 포함하는 쌍을 연결하고 제거하는 것이 수반되어 삭제를 수행할 수 있으며,이 경우 참조 무결성이 유지된다.  

외부 키에 의해 참조되는 듀프를 제거할 수 있는 지 여부는 데이터 정의 언어(DDL)에 의한 참조 무결성 제약 조건(constraint)에 의해 정의된다.  

---

**엔터티 무결성**: 개체 무결성과 동일한 의미를 가진다. 이는 모든 인스턴스는 교유한 값(같은 값이 존재 X)이거나, 널(Null)값이어야 한다는 것을 의미한다.  

---

**식별자의 종류**: 자신의 엔터티 내에서 대표성을 가지는가에 따라 **주식별자(Primary Identifier)**와 **보조식별자(Alternate Identifier)**로 구분한다.  

또한, 엔터티 내에서 스스로 생성되었는지 여부에 따라 **내부식별자**와 **외부식별자(Foreign Identifier)**로 구분할 수도 있고, 단일 속성으로 식별이 되는가에 따라 **단일식별자(Single Identifier)**와 **복합식별자(Composit Identifier)**로 구분할 수도 있다.  

마지막으로 업무적으로 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만든 식별자를 구분하기 위해 **본질식별자**와 **인조식별자**로도 구분할 수 있다.  

![kindofidentifier] (https://raw.githubusercontent.com/rjs1197/rjs1197.github.io/master/img/database/kind_of_uniqueidentifier.jpg)  

---

**식별관계**: 부모테이블의 유니크 키나 기본키로 지정된 컬럼이 자식테이블의 기본키 컬럼과 연결된 경우, 실선으로 표기되는 관계를 의미한다.  

---

**비식별관계**: 부모테이블의 유니크 키나 기본키로 지정된 컬럼이 자식테이블의 일반 컬럼과 연결된 경우, 점선으로 표기되는 관계를 의미한다.  

> 쉽게 이야기하면 부모 컬럼을 참조하는 자식 컬럼이 식별 (PK) 가능하면 **식별 관계**라고 하고 식별이 가능하지 않으면 **비식별 관계**라고 한다. 즉, 자식 컬럼이 PK 인지 아닌지에 따라 나눌 수 있다.
  

---

**순환관계(Recursive Relationship)**: 하나의 엔터티가 다른 엔터티가 아닌 자기 자신과 관계를 맺는 관계를 순환 관계(Recursive Relationship)라고 한다. 이와 같은 순환 관계를 표현한 모델을 순환 구조 모델 또는 순환 모델이라고 하며, [그림 4-2-38]의 좌측에 표현된 조직 구조와 같은 계층 구조를 표현하는 데 유용하다.  

![recursive relationship] (https://raw.githubusercontent.com/rjs1197/rjs1197.github.io/master/img/database/recursive relationship.jpg)  

#### 참고 자료

https://ko.wikipedia.org/wiki/  
https://namu.wiki/w  
http://devbab.tistory.com/  
http://www.dbguide.net/  

