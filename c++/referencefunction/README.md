## Reference Function

##### 참조자에 대해 살펴보자 - 함수편.  

[뒤로가기](/c++/README.md)

이번에는 참조자의 활용에 대해서 살펴보자. 물론 그 전에 Call-by-value와 Call-by-reference의 차이를 살펴보겠다.  

우리가 지금까지 배운 함수의 두 가지 호출방식은 다음과 같다.  

* Call-by-value	- 값을 인자로 전달하는 호출방식  
* Call-by-reference - 주소 값을 인자로 전달하는 호출방식  

이것에 대한 자세한 설명은 여기서 따로 하지 않겠다. 여기서는 아래의 코드로 설명을 대체하고 넘어가겠다.  

```
void SwapByValue(int num1, int num2)
{
	int temp = num1;
    num1 = num2;
    num2 = temp;
}	// Call-by-value

void SwapByRef(int* ptr1, int* ptr2)
{
	int temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr = temp;
}	// Call-by-reference
```

그렇다면 참조자를 이용한 Call-by-reference에 대해 설명하겠다.  

Call-by-reference의 가장 큰 핵심은 함수 내에서 함수 외부에 선언된 변수에 접근할 수 있다는 것이다. 그리고 참조자를 이용해서 함수를 정의하면 이런 일이 가능하다.  

```
void SwapByRef2(int& ref1, int& ref2)
{
	int temp = ref;
    ref1 = ref2;
    ref2 = temp;
}	//Call-by-reference
```

매개변수의 선언 위치에 참조자가 와서 다소 당황스러울 수 있다. 그리고 다음과 같이 질문할 수도 있다.  

> "참조자는 선언과 동시에 변수로 초기화되어야 한다면서!"
  

질문의 답은 "맞다!"이다. 하지만 매개변수는 함수가 호출되어야 초기화가 진행되는 변수들이다.  

즉, 위의 매개변수 선언은 초기화가 이뤄지지 않은 것이 아니라, 함수호출 시 전달되는 인자로 초기화를 하겠다는 의미의 선언이다.  

만약 main에서 아래와 같이 함수를 호출한다면,  

```
int main()
{
	int val1 = 10;
    int val2 = 20;
    SwapByRef2(val1, val2);
    cout << "val1: " << val1 << endl;
    cout << "val2: " << val2 << endl;

    return 0;
}
```

함수가 호출되는 순간 아래와 같은 과정을 거친다고 생각하면 이해할 수 있을 것이다.  

```
SwapByRef2(val1, val2);				//이 호출은
int& ref1 = val1; int& ref2 = val2;	//와 같다.
```

그렇다면 선언과 동시에 변수로 초기화되어야 한다는 것을 이해할 수 있을 것이다.  

또한, SwapByRef2 함수 내에서는 이 두 참조자를 통해서 값의 교환 과정을 거치기 때문에, 그 결과는 실제로 val1과 val2의 값의 교환으로 이어진다.  

참조자의 활용이 상대적으로 포인터의 활용보다 쉽다는 것을 알았다.  

과연 참조자를 이용한 Call-by-reference가 항상 좋은 것일까? 이 질문에 대한 답은 "NO!"다.  

그 이유는 코드를 분석할 때 그 불명확성에 있다.  

예를 들어 아래의 코드를 보면,  

```
int num = 24;
HappyFunc(num);
cout << num << endl;
```
  
이라고 되어있으면 c언어에서는 항상 24가 호출된다는 것을 안다.  

그러나 Cpp에서는 얼마가 출력될지 알 수 없다. 그 이유는 참조자를 이용해서 num에 저장된 값을 변경할 수도 있는 일이기 때문이다.  

그런데 이게 큰 단점일까? 크게 어렵지않은 작업이니까 말이다.  

그런데 이는 코드를 분석하는 과정에서 함수의 호출문장만 보고도 함수의 특성을 어느 정도 판단할 수 있어야 하기 때문에 단점이 된다.  

참조자를 사용하는 경우, 함수의 원형을 확인해야하고, 확인결과 참조자가 매개변수의 선언에 와있다면 함수의 몸체까지 문장 단위로 확인해서 참조자를 통한 값의 변경이 일어나는지 확인해야 한다.  

그렇다면 이러한 단점을 어떻게 해결할까? 안타깝게도 Cpp에서는 완벽하게 해결하는 것은 불가능하다.  

Cpp에서는 최소한 함수 원형을 확인해야 하기 때문이다.  

따라서 완벽한 해결을 위해서는 참조자 기반의 함수정의를 하지 말아야 한다. 앞서 이야기한 단점을 해결하는 방법은 const 키워드를 이용하는 것이다.  

```
void HappyFunc(const int &ref) { . . . . };
```

라고 선언 부분에 명시해주는 것이다.  

이는 "함수 HappyFunc 내에서 참조자 ref를 이용한 값의 변경은 하지 않겠다."라는 의미를 지닌다.  

이 경우에는 당연히 참조자 ref에 값을 저장하는 경우 컴파일 에러가 발생한다.  

그렇다면 또 다른 사례를 보자. 반환형이 참조형인 경우라면 어떻게 할까?  

```
int& RefRetFunc One(int& ref)
{
	ref++
    return ref;
}
```

이 문장을 보고 "아 매개변수가 참조형이니까 이를 반환하기 위해서 반환형도 참조형으로 써줘야 하는구나!"라고 생각할 수 있다.  

그러나 이 생각이 틀리다는 것은 반환형이 참조형이 아닌 경우를 생각해보면 쉽게 알 수 있다.  

```
int RefRetFunc One(int& ref)
{
	ref++
    return ref;
}
```

이처럼 둘 다 전달하는 값은 같다는 것을 알테니 말이다.  

그렇다면 왜 반환형을 참조형으로 했을까? 아래의 코드를 살펴보고 유추해보자.  

```
#include <iostream>
using namespace std;

int RefRetFuncOne(int& ref)
{
	ref++;
    return ref;
}

int& RefRetFuncTwo(int& ref)
{
	ref++;
    return ref;
}

int main()
{
	int num1 = 1;
    int num2 = 1;

    int num3 = RefRetFuncOne(num1);
    //int& num4 = RefRetFuncOne(num1);
    int num5 = RefRetFuncTwo(num2);
    int& num6 = RefRetFuncTwo(num2);

    num1 += 1;
    num2 += 100;
    cout << "num1: " << num1 << endl;
    cout << "num2: " << num2 << endl;
    cout << "num3: " << num3 << endl;
    // cout << "num4: " << num4 << endl;
    cout << "num5: " << num5 << endl;
    cout << "num6: " << num6 << endl;

    return 0;
}
```
  

|실행 결과|
|:--------|
|num1: 3|
|num2: 103|
|num3: 2|
|num5: 2|
|num6: 103|
    

이처럼 실질적으로 참조의 형태를 띄는 것은 num6밖에 없다.  

그 이유는 num3과 num5는 RefRetFuncOne(num1)와 RefRetFuncTwo(num2)를 하나의 값으로 취급해 변수 num3과 num5에 저장했다.  

주석의 num4의 경우에는 참조형이 아닌 변수를 참조해 반환 값이 상수나 다름없어 컴파일 에러가 났다.  

마지막으로 num6의 경우에는 참조형으로 반환된 참조 변수를 다시 참조했기 때문에 정상적으로 참조가 이루어졌다.  

위에서 언급한 num4의 경우와 마찬가지로 아래의 코드도 오류가 난다는 것을 알 수 있을 것이다.  

```
int& RetuRefFunc(int n)
{
	int num = 20;
    num += n;
    return num;
}
```

위 함수에서는 지역변수 num에 저장된 값을 반환하지 않고, num을 참조의 형태로 반환하고 있다.  

따라서 다음의 형태로 함수를 호출하고 나면,  

```
int& ref = RetuRefFunc(10);
```

지역변수 num에 ref라는 또 하나의 이름이 붙게 된다. 하지만 이게 끝이 아니다.  

함수가 반환이 되면, 장직 지역변수 nnum은 소멸이 된다. 따라서 위의 함수처럼 지역변수를 차조형으로 반환하는 일은 없어야한다.  

여기서 강조하는 이유는 컴파일러가 거르지 에러로 거르지 않기 때문이다.  

뿐만 아니라, 아직 채 소멸되지 않은, 찌꺼기의 형태로 남아있는 데이터를 참조해서 정상적인 출력결과를 보이는 경우도 있으니 꼼꼼하게 살필 필요가 있다.  

그리고 const 참조자의 또 다른 특징이 있다. 아래의 코드를 먼저 살펴보자.  

```
const int num = 20;
int& ref = num;	//이 부분에서 컴파일 에러가 난다.
ref += 10;
cout << ref << endl;
```

이 코드는 논리적으로 문제가 있다. const 선언을 통해서 num을 상수화했는데 이 num을 다시 참조자 ref를 통해서 값을 변경하는 것이기 때문이다.  

이것을 허용하면 변수 num의 상수화는 의미가 없다.  

다행히도 이를 허용하지 않는다. 그래도 이는 코드를 읽는 입장에서 다소 명확하지 않아 보인다.  

이를 보다 명확하게 표현하려면 어떻게 해야할까? 아래의 코드가 이를 설명해준다.  

```
const int num = 20;
const int& ref = num;
```

이렇게 선언이 되면 ref를 통한 값의 변경이 불가능하기 때문에 상수화에 대한 논리적인 문제점은 발생하지 않는다.  

그리고 const 참조자는 다음과 같이 상수도 참조가 가능하다.  

```
const int& ref = 20;
```

여기서 당황할 것이다. 지금까지 참조자는 변수만 참조가 가능하다고 설명했는데, 갑자기 상수의 참조를 논하니, 말도 안된다고 생각할 것이다.  

여기에 대한 설명은 아래의 문장을 보고 난 후에 하겠다.  

```
int num = 20 + 30;
```

이처럼 프로그램상에서 표현되는 숫자를 가리켜 '리터럴' 또는 '리터럴 상수'라고 한다. 그리고 이들은 다음과 같은 특징을 갖는다.  

> "임시적으로 존재하는 값이다. 다음 행으로 넘어가면 존재하지 않는 상수이다."
  

이는 덧셈연산을 위해서는 20도, 그리고 30도 모두 메모리 공간에 저장되어야 한다.  

하지만 저장되었다고 해서 재 참조가 가능한 값은 아니다. 즉, 다음 행으로 넘어가면 서멸되는 상수라고 해도 틀리지 않다.  

그런데 이러한 상수를 참조한다는 것이 이치에 맞는다고 생각하는가?  

```
const int& ref = 30;
```

이처럼 말이다. 이는 숫자 30이 메모리 공간에 계속 남아있을 때에나 성립이 가능한 문장이다.  

그래서 Cpp에서는 위의 문장이 성립할 수 있도록, const 참조자를 이용해서 상수를 참조할 때 '임시변수'라는 것을 만든다. 그리고 이 장소에 상수 30을 저장하고선 참조자가 이를 참조하게끔 하는 것이다.  

이는 결과적으로 상수화된 변수를 참조하는 형태가 된다. 그런데 이 부분에서 다음과 같은 의문이 든다.  

> "왜 임시변수라는 잘 와 닿지도 않는 개념까지 끌어들여서 상수의 참조가 가능하게 했지?"  

이는 아래의 함수를 보면 이해할 수 있을 것이다.  

```
int Adder(const int& num1, const int& num2)
{
	return num1 + num2;
}
```

위와 같이 정의된 함수에 인자의 전달을 목적으로 변수를 선언하는 것은 매우 번거롭게 느껴진다.  

그러나 임시변수의 생성을 통한 const 참조자의 상수참조를 허용함으로써, 위의 함수는 다음과 같이 매우 간단히 호출이 가능하다.  

```
cout << Adder(3, 4) << endl;
```

그러나 이러한 형태는 잘 사용되지 않는다. 여기서는 '이러한 것도 있구나~'하고 넘어가도록 하자.  

