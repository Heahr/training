## OOP(Object Oriented Programming)

##### 객체 지향 프로그래밍에서는 객체가 속한 클래스에 객체의 동작을 정의하고, 객체를 사용해 작업을 수행한다. 자바는 객체 지향 프로그래밍을 완전히 수용한 첫 번째 주류 프로그래밍 언어다.  

[뒤로가기](/java/README.md)

시간을 거슬러 객체를 발명하기 전으로 돌아가보면, 당시에는 함수를 호출하는 방식으로 프로그램을 작성했다.  

이미 알고있는 것처럼 이러한 함수는 호출되면 body의 작업을 수행하고, 결과를 반환한다. 이 결과를 어떻게 계산했는지 신경 쓸 필요 없이 그냥 사용하면 된다.  

그래서 함수를 사용하면 작업을 공유할 수 있게 된다. 작업 방법을 몰라도 다른 누군가가 작성한 함수를 호출할 수 있다.  

### 객체를 사용해보자.

앞으로 설명할 '객체'는 여기에 한 차원을 더했다. 객체마다 자신만의 상태(state)가 있다. 이 상태는 메서드를 호출해서 얻는 결과에 영향을 준다. 예를 들어 in이 Scanner의 객체일 때 in.next()를 호출하면 in 객체는 이전에 무엇을 읽었는지 기억하고 다음 입력 토큰을 준다. 현재 in은 자세히 알 수는 없지만 어떠한 상태라는 갖는다는 점을 기억하자.  

다른 사람이 구현한 객체의 메서드를 호출할 때는 내부에서 무슨 일이 일어나는지 몰라도 괜찮다고 했다. 이것은 객체 지향 프로그램의 핵심이며  캡슐화(encapsulation)라고 한다.  

달력의 날짜를 조작하는 작업을 생각해보자. 달력은 월마다 길이가 다르고, 윤년과 윤초까지 있어서 다루기가 좀 까다롭다. 이런 까다로운 세부 사항을 이해하고, 다른 프로그래머가 사용할 수 있는 구현체를 만들어 제공하는 전문가가 있다면 얼마나 좋겠는가!  

이 상황에서 자연스럽게 객체가 등장한다. 예를 들어 날짜 객체의 메서드는 오늘의 요일이나 내일의 날짜 같은 정보를 제공한다.  

자바에서는 날짜를 이해하는 전문가가 날짜와 다른 날짜 관련 개념을 표현하는 클래스를 만들어 제공한다. 날짜를 계산하고 싶다면 이 클래스 중 하나를 사용해 날짜 객체를 생성하고, 요일이나 다음 날짜를 돌려주는 메서드 등을 호출하면 된다.  

이처럼 날짜에 대한 전문가가 그 틀을 클래스로 만들어 제공하고, 우리는 그 클래스를 이용해 날짜 객체를 생성해 사용하자는 이론이 객체 지향 프로그래밍의 밑바탕이 된다. 이제 본격적으로 객체 지향 프로그래밍을 살펴보자.  

#### 달력 만들기  

[예제](/java/acting/ch02/sec01/Cal.java)  

위 예제를 참고하여 객체를 만들어 달력을 구현하는 과정을 살펴보자.  

```
// 만약 acting directory에서 진행한다면 다음을 따라하자.  
javac ch02/sec01/Cal.java

// 현재 날짜의 달력이 나온다.
java ch02.sec01.Cal

// 2018년 06월의 달력이 나온다.
java ch02.sec01.Cal 6 2018
```
  
이제 위의 코드를 살펴보며 'date.plusDays(1)' 메서드 호출을 생각해보자. LocalDate 클래스의 설계자들은 plusDays라는 메서드를 생성할 때 두 가지 방법으로 구현할 수 있었다. 첫 번째 방법은 date 객체의 상태를 변경하고 아무 것도 반환하지 않는다. 두 번째 방법은 date를 변경하지 않고 새로 생성된 LocalDate 객체를 반환하여 다시 date에 넣는다. 예제를 보면 알겠지만 설계자들은 두 번째 방법을 선택했다.  

호출되는 객체를 변경하는 메서드를 'mutator'라고 부른다. 객체를 변경하지 않는 메서드를 'accessor'이라고 부른다. 예를 들어 앞선 LocalDate 클래스의 plusDays는 accessor이다.  

대부분의 메서드가 accessor의 형태를 띄는데, 이는 객체 변경은 위험할 수 있기 때문(특히 두 연산이 객체 하나를 동시에 변경할 때)이다. 이러한 메커니즘의 가장 큰 이유는 CPU의 동시 접근성이 발달함에 따라 이에 대한 안전성이 중요한 문제가 되었기 때문이다. 이 문제를 해결하는 방법 중 하나로 accessor 메서드만 제공해 객체를 'immutable'한 상태로 유지하는 것이다.  

그래도 여전히 변경이 필요할 때가 많다. ArrayList 클래스의 add 메서드가 대표적인 예이다. add를 호출하면 배열 리스트 객체가 변경된다.  

```
ArrayList<String> friends = new ArrayList<>();
	// friends가 비어있다.  
friends.add("Peter");
	// friends의 크기가 1이다.  
```
  
#### 자바에서의 객체 지향

C++ 같은 일부 프로그래밍 언어에서는 변수에 실제 객체(즉, 객체의 상태를 구성하는 비트들)를 담을 수 있다. 그러나 자바에서는 그렇지 않다.  

변수에는 오직 객체 reference만 담을 수 있다. 실제 객체는 다른 곳에 있고, reference는 실제 객체를 찾아내는 구현체 고유의 방법이다.  

> reference는 아주 안전하다는 점을 제외하면 C/C++의 포인터 혹은 참조자와 유사하게 작동한다. C/C++에서는 포인터를 수정하고 포인터로 임의의 메모리 위치를 덮어쓸 수 있다. 하지만 자바의 reference는 특정 객체에만 접근이 가능하다.  

객체 reference(이하 참조)를 담은 변수를 다른 변수에 할당하면 같은 객체 참조를 두 개 갖는다.  

```
ArrayList<String> people = friends;
	// 이제 people과 friends는 같은 객체를 참조한다.  
```
  
공유된 객체를 변경하면 두 참조로 해당 변경 사실을 알 수 있다. 즉, 이 둘은 같은 곳을 가리키고 있다. 여기서 알 수 있는 건 people이나 friends는 객체가 아니고, 같은 배열 리스트 객체의 참조일 뿐이라는 것이다.  

대부분은 이렇게 객체를 공유하면 효율적이고 편리한데, 둘 중 어던 참조로도 공유 객체를 변경할 수 있다는 점에 유의하자.  

하지만, 앞서 봤던 LocalDate나 String과 같은 클래스에 mutator 메서드가 없다면 걱정하지 않아도 된다. 어떤 메서드도 객체를 변경할 수 없으므로 해당 객체에 대한 참조를 얼마든지 공유할 수 있다. 즉, 상태에 대한 고려를 하지 않아도 괜찮다는 말이다.  

마지막으로 다음 할당을 살펴보자.  

```
date = LocalDate.of(year, month, 1);
date = date.plusDays(1);
```
  
첫 번째 할당 후에 date는 지정한 연, 월의 1일을 가리킨다. plusDays 호출은 새 LocalDate 객체를 돌려주며, 두 번째 할당 후 date 변수는 새 객체를 참조한다. 그렇다면 첫 번째 객체는 사라지는 것일까?  

첫 번째 객체는 그것과 관련된 참조가 사라지므로(date의 초기화) 더는 필요 없다. 결국에는 가비지 컬렉터가 메모리를 정리해서 재사용할 수 있게 한다. 자바에서는 이 과정이 자동으로 일어나므로 프로그래머는 메모리 할당 해제를 전혀 걱정하지 않아도 된다.  

### 클래스를 구현해보자.  


