## Database Appendix 2   

#####

[뒤로가기](/database/README.md)

이전 시간에 하지 못한 내용에 대해 간단하게 추가하는 시간을 갖고자 한다. 일종의 보충 느낌이다.  

---

* 속성 정의 시 유의사항을 이해한다.  

속성을 정의할 때는 유의사항이 존재한다. 그 유의사항은 다음과 같다.  

##### 속성 정의 시 유의사항  

1. 의미가 명확한 속성명칭을 부여해야 한다.  

2. 최대한 복합명사를 사용해야 한다. 예를 들어 자유와 여행이 합쳐져 자유여행이 되는 식이다.  

3. 표준 단어를 제정해야 한다. 표준적으로 사용되는 단어들을 사전형식으로 모아둘 필요가 있다.  

4. 작의적 사용을 금지한다. 예를 들어 대충 설계를 진행해 개발자 임의로 속성을 정의하는 것이다.  

* 속성의 성질 원자값  

속성을 정의할 때 또 다른 유의사항으로 원자값이 있다. 이는 속성을 정의할 때는 속성의 최소 단위까지 분할해야 하는 것이다.  

예를들어 매출일자의 분리된 속성은 매출년도, 매출월, 매출일이 있을 수 있다.  

이는 오해가 있을 수 있다. 최소단위까지 분할할 경우 내가 필요하지 않은 속성이 생길 수 있기 때문이다.  

모든 속성이 잘게 존재할 필요는 없지만 각 속성이 최소단위까지 분할된 상태에서 임의로 통합하는 것이 바람직하다. 그렇기 때문에 분할 및 통합의 기준은 업무의 요구사항에 영향을 받는 것이다.  

> 또한, 속성이 하나의 값만을 가지는 것인지도 살펴보아야 한다.  

여러 값을 가지거나 반복되는 속성의 경우는 잘못된 것이다. 이렇게 반복되는 속성은 따로 빼서 엔터티로 관리해야 바람직하다.  

추가적으로 배타적 관계는 가능한 하나의 속성으로 통합하는 것이 바람직하다.  

* 바커표기법에서 속성 Notation에 대하여 이해한다.  

속성 Notation이란 표기법을 말한다. 즉, 이번에는 바커표기법의 속성 표기법에 대해 살펴보자.  

각 속성은 비상속($), 실질 식별자`<primary key>(#)`, `Not Null(*)`, 보조 식별자(#), 선택 속성(o)으로 표기될 수 있다.   

* 속성의 111 원칙에 대하여 이해한다.  

이 원칙은 한 속성값은 한 시점에 한 개의 값만을 가질 수 있다는 원칙을 말한다.  

속성에 의한 엔터티타입 생성의 경우 하나의 속성이 시간이 지남에 따라 여러 개의 값을 가지며 그 값을 해당 업무에서 관리해야 할 필요가 있으면 새로운 엔터티타입을 생성한다는 의미를 지닌다.  

위 내용을 정리해보면 속성의 111 원칙은 한 속성값은 한 시점에 한 개의 값만을 가질 수 있고, 그러한 하나의 속성이 시간이 지남에 따라 여러 시점에서 각 한 개의 값만을 가지게 되고, 그 값을 해당 업무에서 관리해야 할 필요가 있으면 새로운 엔터티 타입을 생성하는 것이 바람직하다.  

* 속성의 3분류에 대하여 이해한다.  

1. 기본속성(basic) : 업무 상 수집된 기본적인 속성  
	
2. 설계속성(designed) : 업무에 필요한 정보를 주기위해 시스템에서 고안된 속성(코드, 일련번호 등)    

3. 유도속성(derived) : 다른 속성에 의해 계산되거나 영향을 받아 생성된 속성(금액총합, 이자 등)  

* 배타적 속성을 이해한다.  

앞서 잠깐 언급했지만 배타적 속성은 말 그대로 한 쪽이 참이면 다른 쪽은 거짓이다. 가령 고객의 서브타입인 법인 고객과 개인 고객이 그 예이다.  

> 한 고객은 개인 고객일 경우 법인 고객으로 관리될 수 없다는 것을 의미한다.  

* 자기참조관계(순환관계)를 이해한다.  

순환관계는 하나의 엔터티가 다른 엔터티가 아닌 자기 자신과 관계를 맺는 관계를 말한다. '조직'과 같은 계층 구조를 표현하는 데 유용하다.  

조직을 예로 들면 회사라는 큰 범주에 각 본부들이 속하고 본부 내에는 여러 부서들이 존재하며, 하나의 부서는 여러 팀을 가지고 있다.  

이러한 관계를 '조직'이라는 하나의 엔터티로 만들어 자기 자신과 관계를 맺어 표현할 수 있다.  

##### 순환관계의 특징  

1. 하나의 순환 엔터티는 각 엔터티의 모든 속성을 포함해야 한다. 예를 들어 조직 엔터티는 각 조직(회사, 본부, 부서 등)의 모든 속성(조직명, 조직 대표(장), 위치 등)을 포함해야 하는 것이다.  

2. 각 계층에 있는 속성은 동일하게 하는 것이 가장 좋다.  

3. 순환 모델은 필수(직선) 관계로 취급될 수 없고(무한 LOOP 발생), 반드시 선택 사양 관계이다.  

4. 순환 모델의 특징은 조직의 변경(추가/삭제)에 쉽게 대응할 수 있다는 것이다.  

* BOM(Bill of Materials) 관계에 대하여 이해한다.  

BOM 관계의 모델을 Network 구조라고 한다. 이러한 network 구조를 제조업에서 부품의 소요량 파악 등의 모델에 유용하게 이용하개 되면서 M:M 순환 구조는 BOM 모델이라 알려지게 된 것이다.  

즉, BOM은 M:M의 순환 관계이다(일반적인 순환 관계는 M:1이다).  

이는 상세 모델링 과정에서 새로운 관계 엔터티(부품을 예로 들면 조립규칙 등)를 추가하여 두 개의 1:M 관계로 구성된 모델로 구체화된다.  

예를 들면 부품이라는 엔터티는 자기 자신에 대해 BOM 관계를 가진다. 여러 개의 상위 부품에 속할 수도 있고, 여러 하위 부품이 필요할 수 있다는 것이다.  

그리고 이는 상세 모델링 과정에서 '조립규칙'이라는 새로운 엔터티에 속하고, 구성된다(1:M 관계 2개로 구체화된다).  

* Arc관계를 이해한다.  

어떤 엔터티가 두 개 이상의 다른 엔터티의 합집합과 관계를 가지는 것을 배타적 관계 혹은 아크 관계라 한다.  

이러한 아크 관계는 동일한 의미의 관계가 서로 다른 하나 이상의 엔터티와 베타적으로 관계를 갖고 있을 때 이를 하나로 통합함으로써 발생하게 되는 것이다.  

예를 들어 출고라는 엔터티에는 공정, 창고, 외주가공처라는 상위 엔터티가 존재한다. 이 셋은 하나의 합집합을 이뤄 '출고' 엔터티와 관계를 가진다.  

> 따라서 이러한 관계를 아크 관계라고 할 수 있는 것이다.  

##### 아크 관계의 특징  

1. 아크 내 있는 관계는 보통 동일하다.  

2. 아크 내에 있는 관계는 항상 필수이거나 선택 사양이어야 한다.  

3. 아크는 반드시 하나의 엔터티에만 속해야 한다(하나의 아크가 여러 엔터티를 가질 수 없다. 여기서의 엔터티는 하위 엔터티를 말한다).  

4. 어떤 엔터티는 다수의 아크를 가질 수 있다. 그러나 지정된 관계는 단 하나의 아크에만 사용되어야 한다.  

* 정규화를 이해한다.  

정규화는 논리적 데이터 모델을 일관성 있고, 중복을 제거하여 보다 안정성을 갖는 바람직한 자료구조로 만들기 위해 여러 단계를 거친다.  

그 단계는 1 ~ 5차 정규형, BCNF(Boyce-Codd Normal Form)까지로 구성되어 있지만 여기서는 1 ~ 3차 정규형까지만 다루도록 하겠다.  

그 이유는 3차 정규화 이후의 정규화는 폭넓게 사용되지 않기 때문이다.  

* 이상현상(Anomaly)에 대하여 이해한다.  

잘 만들어진 데이터 모델이라고 해도 엔터티에 데이터를 삽입, 수정, 삭제할 때 오류가 발생할 개연성을 가지고 있다.  

이러한 것들을 통칭해 '이상현상', '변경 이상'이라 한다. 즉, 데이터의 중복성으로 인해 집합을 조작할 대 예기치 못한 비합리적 현상을 말한다.  

##### 이상현상의 종류  

1. 삽입(입력) 이상 : 어떤 데이터를 삽입하려고 할 때 원하지 않는 데이터도 함께 삽입된다.  

2. 수정(갱신) 이상 : 일부 속성 값을 갱신 함으로써 원하지 않는 정보의 이상 현상(무결성 파괴, 정보의 모순성)이 발생한다.  

3. 삭제 이상 : 일부 정보를 삭제함으로써 유지되어야 할 정보까지도 삭제되는 연대 삭제가 발생한다.  

또한, 이렇게 변경 이상이 발생하는 엔터티를 그대로 운용하게 되면 데이터가 신뢰할 수 없는 값들로 채워질 가능성이 있다.  

즉, 데이터의 일관성과 무결성을 해칠 가능성이 있는 것이다. 그래서 우리는 정규화 과정을 통해 변경 이상의 엔터티를 정규화된 엔터티로 변환해야 하는 것이다.  

* 제1, 2, 3 정규형을 이해하고, 무손실분해를 통한 정규화 과정을 이해한다.  

> 정규화에 대해 다시 한 번 설명하면 이상 현상을 야기하는 속성간의 종속관계를 제거하기 위한 엔터티를 여러 개의 엔터티로 무손실 분해하는 과정이라고 할 수 있다.  

즉, 정규화를 단계 별로 거치며 속성의 위치를 적절하게 하는 것이다.  

##### 정규화의 장점  

1. 중복값이 줄어든다.  
2. NULL 값이 줄어든다.  
3. 복잡한 코드로 데이터 모델을 보완할 필요가 없다.  
4. 새로운 요구사항의 발전 과정을 돕는다.  
5. 데이터 구조의 안정성을 최대화한다.  

##### 정규화 과정  

1. 제 1차 정규형(1NF) : 릴레이션(집합) R에 속한 모든 도메인이 원자값 만으로 되어 있는 경우를 말한다. 모든 속성은 반드시 하나의 값을 가져야 한다(반복형태가 있어서는 안된다). 즉, 속성의 원자화를 진행한다.  

2. 제 2차 정규형(2NF) : 릴레이션 R이 1NF이고, 릴레이션의 기본키가 아닌 속성들이 기본키에 완전히 함수적으로 종속할 경우를 말한다. 모든 속성은 반드시 UID 전부에 종속되어야 한다. 즉, 부분 함수 종속성을 제거한다.  

3. 제 3차 정규형(3NF) : 릴레이션 R이 2NF이고, 기본키가 아닌 모든 속성들이 기본키에 대하여 이행적 함수 종속성의 관계를 가지지 않는 경우를 말한다. 즉, 기본키 외에 속성들간에 함수적 종속성을 가지지 않는 경우를 말한다. UID가 아닌 모든 속성 간에는 서로 종속될 수 없다.  

* 함수의 종속성을 이해한다.  

함수 종속성이란 데이터들이 어떤 기준 값에 의해 항상 종속되는 현상을 말한다.  

또한,함수적 종속성은 속성들 사이의 관계에 대한 제약조건으로 속성 A가 B의 결정자이면, B는 A에 함수적으로 종속된다고 할 수 있는 것이다.  

여기서 결정자는 주어진 릴레이션에서 다른 속성을 고유하게 결정하는 하나 이상의 속성을 말한다.  

예를 들어 아래의 그림을 보면 사원 릴레이션에 사원 번호와 부서 번호가 결정자로 사원 번호는 사원 이름, 주소, 전화번호를 고유하게 결정하고, 부서 번호는 부서 이름을 고유하게 결정한다.  

![funcimg1](http://postfiles8.naver.net/20130421_279/kookh1_1366509039168nV1rK_PNG/%C7%D4%BC%F6%C0%FB%C1%BE%BC%D3%BC%BA.PNG?type=w2)  

##### 함수 종속성의 종류  

1. 완전 함수적 종속성 : 예를 들어 사원 릴레이션에 있는 2개의 결정자를 모두 종속하는 경우인 '직책'이 완전 함수적 종속성에 해당한다.  

2. 부분 함수적 종속성 : 예를 들어 사원 릴레이션에 있는 2개의 결정자 중 하나의 결정자에 종속하는 경우인 사원 이름, 주소, 전화번호, 부서 이름의 경우에는 부분 함수적 종속성에 해당한다.  

![funcimg2](http://postfiles14.naver.net/20130421_93/kookh1_1366509198621FJKaz_PNG/%BF%CF%C0%FC%C7%D4%BC%F6%C0%FB%C1%BE%BC%D3%BC%BA.PNG?type=w2)  

3. 이행 함수적 종속성 : 아래의 그림을 보면 학과 이름과 학과 전화번호는 학번에 부분 함수적 종속성을 지니고, 학점은 학번과 과목 번호에 완전 함수적 종속성을 지닌다.  

마지막으로 학과 전화번호는 학번(결정자)에 의해 부분 함수적 종속성을 가지면서 부분 함수적 종속성을 지니고 있는 학과 이름에 함수적 종속을 갖게 된다. 이 경우 학과 전화번호는 이행 함수적 종속성을 지닌다고 할 수 있다.  

![funcimg3](http://postfiles8.naver.net/20130421_71/kookh1_1366509420233mp2O6_PNG/%C0%CC%C7%E0%C0%FB%C7%D4%BC%F6%C0%FB%C1%BE%BC%D3%BC%BA.PNG?type=w2)
  
* 점이력과 선분이력을 이해한다.  

기록하는 방법에는 두 가지가 있다. 그 중 하나는 발생한 시점을 기록하는 것이고, 나머지 하나는 그것이 발생한 시점과 종료된 시점을 기록하는 것이다.  

전자의 경우에는 '점이력'이라고 부르며, 발생한 그 시점을 점처럼 찍는 것으로 이해할 수 있고, 후자의 경우에는 '선분이력'이라고 부르며 발생한 그 시점부터 종료된 시점까지 선을 긋는 것으로 이해할 수 있다.  

점이력의 경우에는 특정한 시점을 찾기 위해서는 특정 시점보다 작거나 같은 데이터를 모두 읽어 MAX 처리하는 불필요한 작업이 필요하지만 선분이력의 경우에는 특정 시점의 데이터 조회 시 SQL 처리가 단순하다.  

그러나 종료 시점이 미정인 경우 종료 시점을 NULL 또는 최대 값인 9999-12-31 등으로 부여해야 한다는 우려가 있다.  

