## Reference variable

'참조자'라는 것은 성격상 포인터에 비유가 되기 쉽다.(그러나 포인터를 모른다고 이해를 못하는 건 아니니 지레 겁먹지 말도록 하자.) 그래서 포인터를 어느정도 이해하고 있다면 포인터와 비교해서 생각해보는 것도 좋을 것 같다. 그렇다고 무리하게 비교할 필요는 없으니 스스로를 괴롭히지 않았으면 좋겠다.  

---

우선 참조자에 대한 설명 전에 우리가 흔히 알고 있는 '변수'에 대해 생각해보자.  

>"변수는 할당된 메모리 공간에 붙여진 이름이다. 그리고 그 이름을 통해서 해당 메모리 공간에 접근이 가능하다." 
  

그렇다면 '할당된 하나의 메모리 공간'에 둘 이상의 이름을 부여할 수는 없을까? 이 질문은 앞으로 배울 참조자와 관련이 있다.  

그렇다. 참조자는 변수에 별명을 주는 것과 같다고 보면 된다. 그 선언 방법은 아래와 같다.  

```
int &num2 = num1;
```

조금 이상할 수도 있다. 왜냐하면 연산자 '&'는 변수의 주소값을 반환하는 연산자이기 때문이다. 하지만 위의 문장에서 보이듯이 전혀 다른 의미로도 사용된다.  

이미 선언된 변수의 앞에 이 연산자가 오면 주소 값의 반환을 명령하는 뜻이 되지만, 새로 선언되는 변수의 이름 앞에 등장하면, 이는 참조자의 선언을 뜻하게 된다.  

```
int *ptr = &num1;	// 변수 num1의 주소 값을 반환해서 포인터 ptr에 저장하라!
int &num2 = num1;	// 변수 num1에 대한 참조자 num2를 선언해라!
```

따라서 num1의 선언 이후에 다음 문장이 실행되면,  

```
int &num2 = num1;
```

num2는 num1의 '참조자'가 된다.  


앞선 설명에서 참조자는 변수에 별명을 주는 것과 같다고 말했다. 그 이유를 다음의 코드를 통해서 확인해보자.  

```
#include <iostream>
using namespace std;

int main()
{
	int num1 = 1020;
    int &num2 = num1;

    num2 = 3047;
    cout << "VAL: " << num1 << endl;	// 변수 자체를 호출
    cout << "REF: " << num2 << endl;	// 참조자를 호출

    cout << "VAL: " << &num1 << endl;	// 변수 자체의 주소를 호출
    cout << "REF: " << &num2 << endl;	// 참조자의 주소를 호출

    return 0;
}
```

|실행 결과|
|:------------|
|VAL: 3047|
|REF: 3047|
|VAL: 009FFD00|
|REF: 009FFD00|
  

참조자와 변수는 그다지 차이가 없다. 위 예제에서 보이듯이 & 연산자를 이용해서 주소 값을 반환 받을 수도 있고, 함수 내에서 선언된 지역적 참조자는 지역변수와 마찬가지로 함수를 빠져나가면 소멸이 된다.  

그렇다면 또 다른 참조자의 특징은 무엇이 있는지 살펴보자.  

우선 참조자으 수에는 제한이 없고, 참조자를 대상으로도 참조자를 선언할 수 있다! 이 말은 아래의 예시를 통해 자세히 알아보자.  

```
int num1 = 2759;	// 일반 변수
int &num2 = num1;	// 변수를 참조하는 참조자
int &num3 = num2;	// 참조자를 참조하는 참조자
int &num4 = num3;	// 참조자를 참조하는 참조자를 참조하는 참조자
```

당연히 num1과 num4가 가리키는 주소는 같다. 하지만, 필요 이상으로 참조자를 선언하는 것은 바람직하지 않으며, 참조자를 대상으로 또 다른 참조자를 만드는 일이 흔히 필요하지는 않다.  

또한, 참조자는 변수에 대해서만 선언이 가능하고, 선언됨과 동시에 누군가를 참조해야만 한다. 즉, 다음의 선언은 유효하지 않다.  

```
int &ref = 20;
```

또한, 미리 참조자를 선언했다가, 후에 누군가를 참조하는 것은 불가능하며, 참조의 대상을 바꾸는 것도 불가능하다.  

```
int &ref;
```

물론 다음과 같이 NULL로 초기화하는 것도 불가능하다. 포인터 변수는 가능했지만 말이다.  

```
int &ref = NULL;
```

그렇다면 배열은 어떨까? 아래의 코드를 본 후에 설명하도록 하겠다.  

```
#include <iostream>
using namespace std;

int main()
{
	int arr[3] = {1, 3, 5};
    int &ref1 = arr[0];
    int &ref2 = arr[1];
    int &ref3 = arr[2];

    cout << ref1 << endl;
    cout << ref2 << endl;
    cout << ref2 << endl;

	return 0;
}
```
  
예제에서 보이듯이 배열요소는(배열 그 자체가 아니라, 배열의 요소는) 변수로 간주되어 참조자의 선언이 가능하다. 그리고 포인터 변수도 변수이기 때문에 참조자의 선언이 가능하다.  

이와 관련해서는 아래의 예제를 통해 살펴보자.  

```
#include <iostream>
using namespace std;

int main()
{
	int num = 12;
    int *ptr = &num;
    int **dptr = &ptr;

    int &ref = num;
    int *(&pref) = ptr;
    int **(&dpref) = dptr;

    cout << ref << endl;
    cout << *pref << endl;
    cout << **dpref << endl;

    return 0;
}
```
