## Before entering the Inheritance 

'Inheritance(상속)'은 다소 생소한 개념이다. 그래서 이 장을 통해 '상속'을 학습하기 이전에 조금 더 유의미한 학습을 위해 접근방식과 관점에 대해 언급할 것이다. 만약 Java, C#과 같은 객체지향 언어에 익숙하다면 이 장은 넘어가도 좋다.  

---

우선 상속은 특히 코드에 적용하는 것이 중요한 문법이다. 그 이유는 많이 적용(사용)되기 때문이 아니라, 적절한 상황에 선별적으로 적용해야 하는 것이 중요한 것이기 때문이다.  

사실 상속에 대해 많은 책들이 아래와 같은 개념으로 설명한다.  

> "상속은 이런저런 것이고, 이렇게 저렇게 사용하면 됩니다."  

그렇지만 이런 공부 방식은 적용에도, 학습에도 도움이 되지 않는다. 물론 이론적으로 상속이 지니는 문법적 요소를 이해하고 있어야 한다.  

그러나 이보다도 중요한 것은 상속이 가져다 주는 이점을 정확히 이해하는 것이다.  

공부하는 과정에서 감탄사가 나올 때까지 상속을 읽어보도록 하자(이미 알고 있는 개념이 아니라면 감탄사가 나올 것이다).  

그래서 우리는 아래와 같은 과정을 통해 상속을 이해하고, 감탄사를 터트리게 될 것이다.  

> // 문제의 제시
> 상속과 더불어 다형성의 개념을 적용해야만 해결 가능한 문제를 먼저 제시할 것이다.
>
> // 기본개념 소개
> 이론적으로 상속이 지니는 문법적 요소를 하나씩 소개할 것이다. 또한, 그 과정에서 앞서 제시한 문제의 해결책을 함께 고민하도록 하자.
>
> // 문제의 해결
> 처음 제시한 문제를, 상속이라는 개념을 활용/적용하여 해결한다(감탄사를 터트리자).  

C++의 상속은 그 단어의 의미처럼 물려 받는다는 성격이 강하다. 그래서 과거에는 아래와 같이 상속을 정의하였다.  

> "기존에 정의해 놓은 클래스의 재활용을 목적으로 만들어진 문법적 요소가 상속이다."  

물론 상속의 여러 이점 중 하나이지만, 이는 '상속'을 적용하는 근본적인 이유가 되지는 않는다.  

그래서 여기서는 "상속은 재활용의 목적으로만 존재하는 문법적 요소가 아니다."라는 것을 기억하길 바란다.  

그리고 과거의 관점으로 상속을 바라보지 않고, 새로운 관점으로 상속을 바라볼 수 있도록 유도할 것이다. 그러니 잘 따라오기 바란다.  

먼저 **'문제의 제시'**를 위해 하나의 예제를 살펴보자. 이 예제는 회사가 운영하는 '급여관리 시스템'이다.  

이 회사가 처음 이 시스템을 도입할 당시만해도 직원의 근무형태는 '정규직'만 존재했다.  

따라서 이 시스템은 정규직을 관리하기 위한 형태로 설계되었을 것이다. 그럼 아래 클래스를 살펴보자.

```
class PermanentWorker
{
private:
	char name[100];
	int salary;
public:
	PermanentWorker(char *name, int money)
		: salary(money)
	{
		strcpy_s(this->name, name);
	}
	int GetPay() const
	{
		return salary;
	}
	void ShowSalaryInfo() const
	{
		cout << "name: " << name << endl;
		cout << "salary: " << GetPay() << endl << endl;
	}
};
```

이 회사의 정규직 급여는 입사 당시 정해진다. 따라서 이름과 급여정보를 지정할 수 있도록 클래스를 정의한 것이다.  

아래의 코드는 위에서 정의한 클래스의 객체를 저장 및 관리하기 위한 클래스이다.  

PermanentWorker 객체의 저장을 목적으로 배열을 멤버로 지니고 있으며, 저장된 객체의 급여 정보를 출력하기 위한 함수를 멤버로 지니고 있다.  

```
class EmployeeHandler
{
private:
	PermanentWorker *empList[50];
	int empNum;
public:
	EmployeeHandler()
		: empNum(0)
	{
		// empty
	}
	void AddEmployee(PermanentWorker *emp)
	{
		empList[empNum++] = emp;
	}
	void ShowAllSalaryInfo() const 
	{
		for (int i = 0; i < empNum; i++)
			empList[i]->ShowSalaryInfo();
	}
	void ShowTotalSalary() const
	{
		int sum = 0;
		for (int i = 0; i < empNum; i++)
			sum += empList[i]->GetPay();
		cout << "salary sum: " << sum << endl;
	}
	~EmployeeHandler()
	{
		for (int i = 0; i < empNum; i++)
			delete empList[i];
	}
};
```

위의 클래스는 앞서 정의한 PermanentWorker 클래스와 성격이 다르다.  

앞서 정의한 클래스는 데이터적 성격이 강한 반면, 위에서 정의한 클래스는 기능적 성격이 강하다.  

쉽게 말해서 기록의 보전을 위해서 파일에 저장할 데이터를 가지고 잇는 것은 PermanentWorker 객체인 반면, EmployeeHnadler 객체는 프로그램을 구성하는 대표적인 기능들을 처리하는 클래스이다.  

그리고 이렇게 기능의 처리를 실제로 담당하는 클래스를 가리켜 '컨트롤 클래스' 또는 '핸들러 클래스'라고 한다.  

이러한 컨트롤 클래스는 기능 제공의 핵심이기 때문에 모든 객체지향 프로그램에서 반드시 존재하는 클래스이다.  

마지막으로 위의 두 클래스를 기반으로 작성된 main 함수를 살펴보자.  

```
int main()
{
	// 직원관리를 목적으로 설계된 컨트롤 클래스의 객체생성
	EmployeeHandler handler;

	// 직원 등록
	handler.AddEmployee(new PermanentWorker("KIM", 1000));
	handler.AddEmployee(new PermanentWorker("LEE", 2000));
	handler.AddEmployee(new PermanentWorker("JUN", 3000));

    // 이번 달에 지불해야 할 급여의 정보
	handler.ShowAllSalaryInfo();

    // 이번 달에 지불해야 할 급여의 총합
	handler.ShowTotalSalary();

	return 0;

}
```

위 예제는 크게 문제는 없어 보인다. 복잡하지도 않고, 실행결과도 명확히 보이기 때문이다.  

하지만 객체지향을 포함한 모든 소프트웨어의 설계에 있어서 중요시하는 것 중 하나는 다음의 내용이다.  

> 요구사항의 변경에 대응하는 프로그램의 유연성
> 기능의 추가에 따른 프로그램의 확장성  

예를 들어, 프로그램 사용자의 업무 형태가 바뀐다면 프로그램 변경을 요구한다. 혹은 회사의 업무가 확장되어 프로그램의 기능추가를 요구할 수도 있는 일이다.  

그런데 좋은 프로그램은 이러한 요구에 대처가 가능해야 한다. 즉, 프로그램 사용자의 요구에 아래와 같이 대답한다면 그것은 다소 문제가 있는 것이다.  

> "그 기능을 변경하려면, 프로그램을 거의 처음부터 다시 만들다시피 해야 하는데요.. :("  

사실 이러한 유연성과 확장성을 확보하는 것은 쉽지 않은 일이다.  

따라서 이를 모두 만족하는 프로그램을 구현한다는 것은 생각하기 어렵다.  

다만, 조금이라도 더 유연하게, 조금이라도 더 확장성이 좋게 프로그램을 디자인하려고 노력할 뿐이다.  

그럼 이제 우리가 구현한 위의 예제는 유연성과 확장성이 얼마나 확보되어 있는지 살펴보도록 하자.  

예를 들어 우리 회사에 사용자가 아래와 같은 요구를 해왔다고 가정하자.  

> "부서가 세분화되고, 직원도 많이 채용했습니다. 그러다 보니 예전에 스던 프로그램이 이제는 조금 맞지가 않네요. 왜냐하면 직원의 고용형태가 다양해졌거든요."
  

앞서 말한 것처럼 이전에는 '정규직'만 존재하던 고용 형태가 늘어난 것이다. 예를 들어 아래의 두 형태이다.  

* 영업직: 인센티브 개념이 도입되어야 한다.
* 임시직: 학생들을 대상으로 하는 인턴/아르바이트 개념이다.  

이 중에서 영업직은 판매의 장려를 위해서 기본급여뿐 아니라, 판매실적에 따른 인센티브 제도까지 적용받는 고용형태이다.  

그리고 임시직은 학생들이 방학기간에 일할 수 있도록 돕는 고용형태이다.  

그런데, 사실 고용의 형태가 다양하더라도 급여의 계산방식만 동일하면 이를 특별히 구분할 필요가 없다.  

하지만 안타깝게도 이들은 급여의 계산방식에 있어서 다음과 같은 차이를 보인다.  

* 고용직(정규직) 급여: 연봉제이다. 따라서 매 달의 급여가 정해져있다(포괄임금제).
* 영업직 급여: '기본급여 + 인센티브'의 형태를 지닌다.
* 임시직 급여: '시간당 급여 X 일한 시간'의 형태를 지닌다.  

따라서 우리가 요구사항을 만족시키기 위해서는 영업직과 임시직의 특성을 프로그램 내에 반영해야 한다.  

그렇다면 아래와 같이 쉽게 생각할 수도 있지 않을까?  

> "영업직을 의미하는 SalesMan 클래스와 임시직을 의미하는 Remporary 클래스를 추가하면 되겠군.. 쉽네?"  

하지만, 문제는 다른 곳에 있다. SalesMan 클래스와 Temporary 클래스를 추가했을 때, 이를 반영하기 위해서 EmployeeHandler 클래스가 어떻게 변경되어야 할지 생각해보자.  

> "SalesMan 객체와 Temporary 객체의 저장을 위한 배열을 두 개 추가하고, 각각의 배열에 저장된 객체의 수를 별도로 세어야 하니, 정수형 변수도 멤버로 두 개 추가해야 하네.. 조금 복잡한 걸?"  

하지만 여기서 끝이 아니다.  

> "AddEmployee 함수는 SalesMan 객체용과 Temporary 객체용으로 각각 추가되어야 하고, 급여정보를 출력하는 나머지 두 멤버함수는 총 3개의 배열을 대상으로 연산을 진행해야 하니까, 반복문이 추가로 각각 두 개씩 삽입되어야 하는구만! 
> 휴.. 이거 다 바꿔야 하는 거 아니야?"  

그렇다. 결과적으로 바뀌지 않는 부분이 하나도 없다. 즉, 대대적인 공사에 들어가야 하는 것이다.  

따라서 우리가 구현한 위 예제는 확장성이 구린 상태이다. 확장성을 좋게 하기 위해서는 클래스 추가로 인한 변경을 최소화할 수 있어야 한다.  

이왕이면 특히 변화가 심한 EmployeeHandler 클래스를 조금도 변경하지 않아도 된다면, 매우 좋은 확장성을 가졌다고 할 수 있을 것이다.  

과연 가능할까? 가능하다! 이제부터 우리가 공부할 '상속'을 적용하면 이러한 일도 가능한 것이다!  

그럼 이제 이 문제의 해결을 목적으로 본격적인 '상속' 공부를 시작해보자. 만약 상속을 제대로 공부하고, 이해한다면 이 문제는 금방 해결할 수 있을 것이다.  
